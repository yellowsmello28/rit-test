<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Drawing App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on touch devices while drawing */
            overflow: hidden; /* Prevents body scroll */
        }
        canvas {
            cursor: crosshair;
            display: block; /* Removes bottom margin */
        }
        /* Custom transition for smooth sidebar and content shift */
        #toolbar, #mainContent {
            transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }
        /* Style for the active tool button */
        .tool-btn.active {
            border-color: #60a5fa; /* blue-400 */
            background-color: #dbeafe; /* blue-100 */
            font-weight: 700;
        }
        /* Styles for disabled buttons */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-slate-100 flex h-screen">

    <!-- Collapsible Toolbar -->
    <div id="toolbar" class="fixed top-0 left-0 h-full w-64 bg-white shadow-lg p-6 flex flex-col gap-8 z-20 transform overflow-y-auto">
        <h2 class="text-2xl font-bold text-slate-800">Tools</h2>
        
        <!-- Controls Section -->
        <div class="controls flex flex-col gap-6">
            <!-- Color Picker -->
            <div id="colorControls" class="flex flex-col gap-2">
                <label for="colorPicker" class="text-md font-medium text-slate-600">Color</label>
                <input type="color" id="colorPicker" value="#000000" class="w-full h-12 p-1 bg-white border border-slate-300 rounded-lg cursor-pointer">
                 <!-- Recent Colors -->
                <div class="flex flex-col gap-2 pt-2">
                    <label class="text-md font-medium text-slate-600">Recent</label>
                    <div id="recentColorsContainer" class="grid grid-cols-6 gap-2">
                        <!-- Swatches generated by JS -->
                    </div>
                </div>
            </div>

            <!-- General Brush Controls -->
            <div class="flex flex-col gap-2">
                <label id="brushSizeLabel" for="brushSize" class="text-md font-medium text-slate-600">Brush Size</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="brushSize" min="1" max="100" value="10" class="w-full cursor-pointer">
                    <span id="brushSizeValue" class="font-medium text-slate-700 w-8 text-center bg-slate-100 rounded-md py-1">10</span>
                </div>
            </div>
            
            <div id="opacityControl" class="flex flex-col gap-2">
                <label for="opacitySlider" class="text-md font-medium text-slate-600">Opacity</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="opacitySlider" min="0.01" max="1" value="1" step="0.01" class="w-full cursor-pointer">
                    <span id="opacityValue" class="font-medium text-slate-700 w-10 text-center bg-slate-100 rounded-md py-1">1.0</span>
                </div>
            </div>

            <!-- Pencil-Specific Controls -->
            <div id="pencilControls" class="flex flex-col gap-2">
                <label for="softnessSlider" class="text-md font-medium text-slate-600">Pencil Softness</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="softnessSlider" min="0" max="1" value="0" step="0.05" class="w-full cursor-pointer">
                    <span id="softnessValue" class="font-medium text-slate-700 w-10 text-center bg-slate-100 rounded-md py-1">0.0</span>
                </div>
            </div>

            <!-- Blur-Specific Controls -->
            <div id="blurControls" class="hidden flex-col gap-2">
                 <label for="blurStrengthSlider" class="text-md font-medium text-slate-600">Blur Strength</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="blurStrengthSlider" min="1" max="20" value="5" step="1" class="w-full cursor-pointer">
                    <span id="blurStrengthValue" class="font-medium text-slate-700 w-8 text-center bg-slate-100 rounded-md py-1">5</span>
                </div>
            </div>

            <!-- Brush Types -->
            <div class="flex flex-col gap-2">
                <label class="text-md font-medium text-slate-600">Brush Type</label>
                <div id="brush-options" class="grid grid-cols-2 gap-2">
                    <button data-brush="pencil" class="tool-btn active p-2 border-2 rounded-lg text-sm">Pencil</button>
                    <button data-brush="marker" class="tool-btn p-2 border-2 border-slate-200 rounded-lg text-sm">Marker</button>
                    <button data-brush="airbrush" class="tool-btn p-2 border-2 border-slate-200 rounded-lg text-sm">Airbrush</button>
                    <button data-brush="blur" class="tool-btn p-2 border-2 border-slate-200 rounded-lg text-sm">Blur</button>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col gap-3 pt-4 border-t">
                 <button id="fillBtn" class="tool-btn w-full px-4 py-2 flex items-center justify-center gap-2 bg-white border-2 border-slate-300 text-slate-700 font-semibold rounded-lg hover:bg-slate-100 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2.822 1.756a.5.5 0 0 0-.79.41v1.088c0 .289.21.527.49.555.283.028.51-.188.51-.46V2.64a.5.5 0 0 0-.21-.41zm6.942 0a.5.5 0 0 0-.21.41v1.088c0 .272.227.5.51.46.28-.028.49-.266.49-.555V2.166a.5.5 0 0 0-.79-.41zM4.39 3.332a.5.5 0 0 0-.41.79l.525.867a.5.5 0 0 0 .79-.41l-.525-.867a.5.5 0 0 0-.38-.38zm5.82 0a.5.5 0 0 0-.38.38l-.525.867a.5.5 0 0 0 .79.41l.525-.867a.5.5 0 0 0-.41-.79zM.566 6.332a.5.5 0 0 0-.555.49v1.336c0 .289.188.51.46.51.272 0 .5-.227.46-.51V7.24a.5.5 0 0 0-.365-.478zm14.868 0a.5.5 0 0 0-.365.478v1.088c-.04.283.188.51.46.51.272 0 .555-.221.555-.51V6.822a.5.5 0 0 0-.645-.49zM12.64 15.5a.5.5 0 0 0 .41-.21l.867-.525a.5.5 0 0 0-.41-.79l-.867.525a.5.5 0 0 0-.21.41zm-9.28 0a.5.5 0 0 0-.21-.41l-.867-.525a.5.5 0 0 0-.41.79l.867.525a.5.5 0 0 0 .62.025zM6.822.566a.5.5 0 0 0-.49.645v.365c0 .283.221.555.51.555.289 0 .527-.21.555-.49V1.43a.5.5 0 0 0-.41-.655zm2.356 0a.5.5 0 0 0-.41.655v.365c.028.28.266.49.555.49.289 0 .5-.272.49-.555V1.21a.5.5 0 0 0-.645-.645zM15.434 9.178a.5.5 0 0 0-.49.365l-.143.465c-.04.283.188.51.46.51.272 0 .555-.221.555-.51l.143-.465a.5.5 0 0 0-.525-.365zM.566 9.178a.5.5 0 0 0-.525.365l.143.465c.028.289.283.51.555.51.272 0 .49-.188.46-.46L1.04 9.543a.5.5 0 0 0-.475-.365zM15.5 4.39a.5.5 0 0 0-.21-.41l-.867-.525a.5.5 0 0 0-.41.79l.867.525a.5.5 0 0 0 .62.025zM.5 4.39a.5.5 0 0 0-.21.41l.21.41c.217.217.553.217.77 0l.525-.867a.5.5 0 0 0-.41-.79L.5 4.39z"/></svg>
                    Fill
                 </button>
                 <button id="eraserBtn" class="tool-btn w-full px-4 py-2 bg-white border-2 border-slate-300 text-slate-700 font-semibold rounded-lg hover:bg-slate-100 transition-colors duration-200">Eraser</button>
                <button id="clearBtn" class="w-full px-4 py-2 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600 transition-colors duration-200">Clear Canvas</button>
            </div>
        </div>
    </div>

    <!-- Toolbar Toggle Button -->
    <button id="toolbarToggle" class="fixed top-5 left-64 w-10 h-10 bg-white rounded-full shadow-lg flex items-center justify-center z-30 transition-all duration-300">
        <svg class="w-6 h-6 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
    </button>

    <!-- Main Content Area -->
    <div id="mainContent" class="flex-grow w-full h-full p-8 pl-72">
        <div class="relative w-full h-full bg-white rounded-2xl shadow-lg overflow-hidden">
            <canvas id="drawingCanvas"></canvas>
            <!-- Watermark Tag -->
            <div class="absolute bottom-2 right-4 text-sm text-slate-900 opacity-25 pointer-events-none">
                yellow
            </div>
            <!-- Undo/Redo Buttons -->
            <div class="absolute bottom-4 left-1/2 -translate-x-1/2 flex gap-3">
                <button id="undoBtn" class="bg-white rounded-full p-3 shadow-md hover:bg-slate-100 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M12.5 1a.5.5 0 0 0-1 0V3.14L4.893 5.37a.5.5 0 1 0 .214.962L12 4.41V6.5a.5.5 0 0 0 1 0V1zM11.903 8.35a.5.5 0 0 0-.214-.962L3.5 5.14a.5.5 0 0 0 0 1L11.5 8.36V11a.5.5 0 0 0 1 0V8.5a.5.5 0 0 0-.597-.49zM2.5 13a.5.5 0 0 0 0 1h8a.5.5 0 0 0 0-1h-8z"/></svg>
                </button>
                <button id="redoBtn" class="bg-white rounded-full p-3 shadow-md hover:bg-slate-100 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" transform="scale(-1, 1)" viewBox="0 0 16 16"><path d="M12.5 1a.5.5 0 0 0-1 0V3.14L4.893 5.37a.5.5 0 1 0 .214.962L12 4.41V6.5a.5.5 0 0 0 1 0V1zM11.903 8.35a.5.5 0 0 0-.214-.962L3.5 5.14a.5.5 0 0 0 0 1L11.5 8.36V11a.5.5 0 0 0 1 0V8.5a.5.5 0 0 0-.597-.49zM2.5 13a.5.5 0 0 0 0 1h8a.5.5 0 0 0 0-1h-8z"/></svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        window.addEventListener('load', () => {
            const canvas = document.getElementById('drawingCanvas');
            const ctx = canvas.getContext('2d');
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const snapshotCanvas = document.createElement('canvas');
            const snapshotCtx = snapshotCanvas.getContext('2d');

            // --- Tool Elements ---
            const colorPicker = document.getElementById('colorPicker');
            const recentColorsContainer = document.getElementById('recentColorsContainer');
            const brushSize = document.getElementById('brushSize');
            const brushSizeLabel = document.getElementById('brushSizeLabel');
            const brushSizeValue = document.getElementById('brushSizeValue');
            const opacitySlider = document.getElementById('opacitySlider');
            const opacityValue = document.getElementById('opacityValue');
            const softnessSlider = document.getElementById('softnessSlider');
            const softnessValue = document.getElementById('softnessValue');
            const blurStrengthSlider = document.getElementById('blurStrengthSlider');
            const blurStrengthValue = document.getElementById('blurStrengthValue');
            const brushOptions = document.getElementById('brush-options');
            const clearBtn = document.getElementById('clearBtn');
            const eraserBtn = document.getElementById('eraserBtn');
            const fillBtn = document.getElementById('fillBtn');
            const toolbar = document.getElementById('toolbar');
            const toolbarToggle = document.getElementById('toolbarToggle');
            const mainContent = document.getElementById('mainContent');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            // --- Control Group Elements ---
            const pencilControls = document.getElementById('pencilControls');
            const blurControls = document.getElementById('blurControls');
            const opacityControl = document.getElementById('opacityControl');
            const colorControls = document.getElementById('colorControls');

            // --- Drawing State ---
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            let currentColor = '#000000';
            let currentOpacity = 1.0;
            let currentSoftness = 0;
            let currentBlurStrength = 5;
            let currentTool = 'pencil';
            let isToolbarOpen = true;
            let history = [];
            let redoStack = [];
            let recentColors = [];

            // --- Canvas Sizing (FIXED) ---
            function resizeCanvas() {
                const parent = canvas.parentElement;
                
                // Use the last saved state from history to prevent losing parts of the drawing
                // that are temporarily off-screen during a resize.
                const lastFullState = history.length > 0 ? history[history.length - 1] : null;

                const newWidth = parent.clientWidth;
                const newHeight = parent.clientHeight;
                
                // Avoid unnecessary redraws if dimensions haven't changed
                if (canvas.width === newWidth && canvas.height === newHeight) {
                    return;
                }

                // Set new dimensions for all canvases
                canvas.width = newWidth;
                canvas.height = newHeight;
                tempCanvas.width = newWidth;
                tempCanvas.height = newHeight;
                snapshotCanvas.width = newWidth;
                snapshotCanvas.height = newHeight;

                // Restore the last full drawing state onto the resized canvas
                if (lastFullState) {
                    const mainImage = new Image();
                    mainImage.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(mainImage, 0, 0);
                    };
                    mainImage.src = lastFullState;
                }
                
                // Re-apply context settings as they are reset on resize
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                tempCtx.lineCap = 'round';
                tempCtx.lineJoin = 'round';
            }
            
            // Initial setup
            resizeCanvas();
            renderRecentColors();
            if (history.length === 0) {
                 saveState(); // Save the initial blank state
            }
            updateToolUI();

            // --- Event Listeners ---
            canvas.addEventListener('mousedown', handleInteractionStart);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', handleInteractionEnd);
            canvas.addEventListener('mouseout', handleInteractionEnd);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInteractionStart(e.touches[0]); });
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e.touches[0]); });
            canvas.addEventListener('touchend', handleInteractionEnd);
            
            colorPicker.addEventListener('change', (e) => {
                currentColor = e.target.value;
                updateRecentColors(currentColor);
            });
            
            recentColorsContainer.addEventListener('click', (e) => {
                if (e.target.dataset.color) {
                    currentColor = e.target.dataset.color;
                    colorPicker.value = currentColor;
                }
            });

            brushSize.addEventListener('input', (e) => { brushSizeValue.textContent = e.target.value; });
            opacitySlider.addEventListener('input', (e) => {
                currentOpacity = parseFloat(e.target.value);
                opacityValue.textContent = currentOpacity.toFixed(2);
            });
            softnessSlider.addEventListener('input', (e) => {
                currentSoftness = parseFloat(e.target.value);
                softnessValue.textContent = currentSoftness.toFixed(1);
            });
            blurStrengthSlider.addEventListener('input', (e) => {
                currentBlurStrength = parseInt(e.target.value, 10);
                blurStrengthValue.textContent = currentBlurStrength;
            });
            clearBtn.addEventListener('click', () => {
                saveState();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                saveState();
            });
            
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const tool = e.currentTarget.id.replace('Btn', '') || e.currentTarget.dataset.brush;
                    if (tool) {
                        currentTool = tool;
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        canvas.style.cursor = tool === 'fill' ? 'copy' : 'crosshair';
                        updateToolUI();
                    }
                });
            });

            toolbarToggle.addEventListener('click', () => {
                isToolbarOpen = !isToolbarOpen;
                toolbar.style.transform = isToolbarOpen ? 'translateX(0)' : 'translateX(-100%)';
                toolbarToggle.style.left = isToolbarOpen ? '16rem' : '1rem';
                toolbarToggle.innerHTML = isToolbarOpen ? '<svg class="w-6 h-6 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>' : '<svg class="w-6 h-6 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>';
                mainContent.style.paddingLeft = isToolbarOpen ? '18rem' : '2rem';
                setTimeout(resizeCanvas, 300);
            });

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            window.addEventListener('resize', resizeCanvas);

            // --- UI Update Function ---
            function updateToolUI() {
                pencilControls.classList.add('hidden');
                blurControls.classList.add('hidden');
                opacityControl.classList.remove('hidden');
                colorControls.classList.remove('hidden');

                if (currentTool === 'pencil') {
                    pencilControls.classList.remove('hidden');
                    brushSizeLabel.textContent = 'Brush Size';
                } else if (currentTool === 'blur') {
                    blurControls.classList.remove('hidden');
                    opacityControl.classList.add('hidden');
                    colorControls.classList.add('hidden');
                    brushSizeLabel.textContent = 'Blur Area';
                } else {
                    brushSizeLabel.textContent = 'Brush Size';
                }
            }

            // --- History Functions ---
            function saveState() {
                // Prevent saving identical states consecutively
                if (history.length > 0 && history[history.length - 1] === canvas.toDataURL()) {
                    return;
                }
                history.push(canvas.toDataURL());
                redoStack = []; // Clear redo stack on new action
                updateUndoRedoButtons();
            }

            function undo() {
                if (history.length > 1) {
                    redoStack.push(history.pop());
                    const lastState = new Image();
                    lastState.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(lastState, 0, 0);
                    };
                    lastState.src = history[history.length - 1];
                }
                updateUndoRedoButtons();
            }

            function redo() {
                if (redoStack.length > 0) {
                    const nextStateData = redoStack.pop();
                    history.push(nextStateData);
                    const nextState = new Image();
                    nextState.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(nextState, 0, 0);
                    };
                    nextState.src = nextStateData;
                }
                updateUndoRedoButtons();
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = history.length <= 1;
                redoBtn.disabled = redoStack.length === 0;
            }

            // --- Color Palette Functions ---
            function updateRecentColors(color) {
                if(recentColors.includes(color)) {
                   recentColors = recentColors.filter(c => c !== color);
                }
                recentColors.unshift(color);
                recentColors = recentColors.slice(0, 6);
                renderRecentColors();
            }

            function renderRecentColors() {
                recentColorsContainer.innerHTML = '';
                for (let i = 0; i < 6; i++) {
                    const color = recentColors[i];
                    const swatch = document.createElement('button');
                    swatch.className = 'w-full h-8 rounded border-2 border-slate-200 cursor-pointer';
                    if (color) {
                        swatch.style.backgroundColor = color;
                        swatch.dataset.color = color;
                    } else {
                        swatch.style.backgroundColor = '#f1f5f9'; // bg-slate-100
                        swatch.disabled = true;
                    }
                    recentColorsContainer.appendChild(swatch);
                }
            }

            // --- Drawing Functions ---
            function handleInteractionStart(e) {
                const pos = getMousePos(e);
                if (currentTool === 'fill') {
                    saveState();
                    floodFill(Math.floor(pos.x), Math.floor(pos.y));
                    saveState();
                    return;
                }
                isDrawing = true;
                [lastX, lastY] = [pos.x, pos.y];
                // Take a snapshot of the current canvas state for live preview
                snapshotCtx.clearRect(0, 0, snapshotCanvas.width, snapshotCanvas.height);
                snapshotCtx.drawImage(canvas, 0, 0);
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            }

            function handleInteractionEnd() {
                if (!isDrawing) return;
                isDrawing = false;
                // Finalize the drawing from the temp canvas to the main canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(snapshotCanvas, 0, 0);

                if (currentTool === 'blur') {
                    ctx.drawImage(tempCanvas, 0, 0);
                } else {
                    ctx.globalAlpha = currentOpacity;
                    ctx.drawImage(tempCanvas, 0, 0);
                    ctx.globalAlpha = 1.0;
                }
                
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                saveState();
            }

            function draw(e) {
                if (!isDrawing) return;
                const pos = getMousePos(e);
                const isBrush = ['pencil', 'marker', 'airbrush', 'blur'].includes(currentTool);

                if (isBrush) {
                    drawSegmentOnTemp(pos);
                    showLivePreview();
                } else if (currentTool === 'eraser') {
                    drawEraserSegment(pos);
                }
                [lastX, lastY] = [pos.x, pos.y];
            }
            
            function showLivePreview() {
                // Restore the snapshot, then draw the temp canvas on top for preview
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(snapshotCanvas, 0, 0);
                if (currentTool === 'blur') {
                     ctx.drawImage(tempCanvas, 0, 0);
                } else {
                    ctx.globalAlpha = currentOpacity;
                    ctx.drawImage(tempCanvas, 0, 0);
                    ctx.globalAlpha = 1.0;
                }
            }

            function drawSegmentOnTemp(pos) {
                // Setup context for the temporary canvas where strokes are drawn
                tempCtx.fillStyle = currentColor;
                tempCtx.strokeStyle = currentColor;
                tempCtx.lineWidth = brushSize.value;
                tempCtx.globalAlpha = 1; 
                tempCtx.shadowBlur = 0;
                
                const dx = pos.x - lastX;
                const dy = pos.y - lastY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                // Interpolate points for a smooth line regardless of mouse speed
                for (let i = 0; i < distance; i+=1) {
                    const x = lastX + Math.cos(angle) * i;
                    const y = lastY + Math.sin(angle) * i;
                    
                    switch (currentTool) {
                        case 'marker':
                            const size = brushSize.value;
                            tempCtx.fillRect(x - size / 2, y - size / 2, size, size);
                            break;
                        case 'airbrush':
                            const radius_air = brushSize.value / 2;
                            const gradient_air = tempCtx.createRadialGradient(x, y, 0, x, y, radius_air);
                            gradient_air.addColorStop(0, currentColor);
                            gradient_air.addColorStop(0.4, hexToRgbaString(currentColor, 0.1));
                            gradient_air.addColorStop(1, hexToRgbaString(currentColor, 0));
                            tempCtx.fillStyle = gradient_air;
                            tempCtx.beginPath();
                            tempCtx.arc(x, y, radius_air, 0, Math.PI * 2);
                            tempCtx.fill();
                            break;
                         case 'blur':
                            const radius_blur = brushSize.value / 2;
                            // We draw a small piece of the blurred snapshot at each point.
                            // This creates a continuous, smooth blur stroke.
                            tempCtx.save();
                            tempCtx.beginPath();
                            // Create a circular clipping path for the brush dab
                            tempCtx.arc(x, y, radius_blur, 0, Math.PI * 2);
                            tempCtx.clip();
                            // Apply the blur filter
                            tempCtx.filter = `blur(${currentBlurStrength}px)`;
                            // Draw the original snapshot into the clipped, filtered area
                            tempCtx.drawImage(snapshotCanvas, 0, 0);
                            tempCtx.restore();
                            break;
                        case 'pencil':
                        default:
                            const radius_pencil = brushSize.value / 2;
                            const gradientRadius = radius_pencil * (1 + currentSoftness * 3);
                            const gradient_pencil = tempCtx.createRadialGradient(x, y, 0, x, y, gradientRadius);
                            const coreRadius = radius_pencil * (1 - currentSoftness);
                            const solidStop = Math.max(0, coreRadius / gradientRadius);
                            
                            gradient_pencil.addColorStop(0, currentColor);
                            gradient_pencil.addColorStop(solidStop, currentColor);
                            gradient_pencil.addColorStop(1, hexToRgbaString(currentColor, 0));
                            
                            tempCtx.fillStyle = gradient_pencil;
                            tempCtx.beginPath();
                            tempCtx.arc(x, y, gradientRadius, 0, Math.PI * 2);
                            tempCtx.fill();
                            break;
                    }
                }
            }

            function drawEraserSegment(pos) {
                // Eraser draws directly on the main canvas for immediate effect
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = brushSize.value;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
            }

            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX ?? e.touches[0]?.clientX;
                const clientY = e.clientY ?? e.touches[0]?.clientY;
                return { x: clientX - rect.left, y: clientY - rect.top };
            }

            function floodFill(startX, startY) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const startColor = getPixel(imageData, startX, startY);
                const fillColor = hexToRgba(currentColor, currentOpacity);

                if (colorsMatch(startColor, fillColor)) return;
                
                const pixelStack = [[startX, startY]];
                while (pixelStack.length) {
                    const [x, y] = pixelStack.pop();
                    const currentColor = getPixel(imageData, x, y);
                    if (colorsMatch(currentColor, startColor)) {
                        setPixel(imageData, x, y, fillColor);
                        if (x > 0) pixelStack.push([x - 1, y]);
                        if (x < canvas.width - 1) pixelStack.push([x + 1, y]);
                        if (y > 0) pixelStack.push([x, y - 1]);
                        if (y < canvas.height - 1) pixelStack.push([x, y + 1]);
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            }

            // --- Helper Functions ---
            function getPixel(imageData, x, y) {
                if (x < 0 || y < 0 || x >= imageData.width || y >= imageData.height) return [-1, -1, -1, -1]; // Out of bounds
                const offset = (y * imageData.width + x) * 4;
                return imageData.data.slice(offset, offset + 4);
            }
            function setPixel(imageData, x, y, color) {
                const offset = (y * imageData.width + x) * 4;
                imageData.data[offset] = color[0];
                imageData.data[offset + 1] = color[1];
                imageData.data[offset + 2] = color[2];
                imageData.data[offset + 3] = color[3];
            }
            function colorsMatch(c1, c2) {
                const threshold = 10; // Allow for some tolerance in color matching
                return Math.abs(c1[0] - c2[0]) < threshold && Math.abs(c1[1] - c2[1]) < threshold && Math.abs(c1[2] - c2[2]) < threshold && Math.abs(c1[3] - c2[3]) < threshold;
            }
            function hexToRgba(hex, alpha = 1) {
                let r = 0, g = 0, b = 0;
                if (hex.length == 4) {
                    r = "0x" + hex[1] + hex[1];
                    g = "0x" + hex[2] + hex[2];
                    b = "0x" + hex[3] + hex[3];
                } else if (hex.length == 7) {
                    r = "0x" + hex[1] + hex[2];
                    g = "0x" + hex[3] + hex[4];
                    b = "0x" + hex[5] + hex[6];
                }
                return [+r, +g, +b, Math.floor(alpha * 255)];
            }
            function hexToRgbaString(hex, alpha = 1) {
                const [r, g, b] = hexToRgba(hex);
                return `rgba(${r},${g},${b},${alpha})`;
            }
        });
    </script>
</body>
</html>


